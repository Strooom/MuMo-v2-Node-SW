# Version Management System

## Overview

The version management system automatically embeds build metadata into the firmware, allowing runtime access to version information, build timestamps, and build environment details. The system generates `buildinfo.cpp` dynamically during compilation, with different implementations for local development builds and CI/production builds.

## Architecture

### Static Interface (buildinfo.hpp)

The firmware accesses build information through the `buildInfo` class:

```cpp
class buildInfo {
  public:
    static const buildEnvironment theBuildEnvironment;  // local or ci
    static const buildType theBuildType;                // development, production, or integrationTest
    static const unsigned int mainVersionDigit;         // Major version (e.g., 2 in v2.1.3)
    static const unsigned int minorVersionDigit;        // Minor version (e.g., 1 in v2.1.3)
    static const unsigned int patchVersionDigit;        // Patch version (e.g., 3 in v2.1.3)
    static const char* lastCommitTag;                   // Short git commit hash
    static const char* buildTimeStamp;                  // Human-readable build time
    static const time_t buildEpoch;                     // Unix epoch timestamp of build
};
```

### Build Environment Types

**buildEnvironment** (lib/version/buildenvironment.hpp):
- `local`: Built on developer's machine
- `ci`: Built by GitHub Actions
- `unknown`: Fallback/error state

**buildType** (lib/version/buildtype.hpp):
- `development`: Local development builds with debugging enabled
- `production`: Release builds optimized for deployment
- `integrationTest`: Special builds for integration testing
- `unknown`: Fallback/error state

### Generated File (buildinfo.cpp)

This file is **automatically generated** and should never be manually edited. It's excluded from version control (via .gitignore) and regenerated on every build.

**Header comment in generated file:**
```cpp
// ##########################################################################
// ### This file is generated by Build and Continuous Integration scripts ###
// ###   .github/workflows/buildinfo.py for local development environment ###
// ###   .github/workflows/testbuildrelease.yml for CI environment        ###
// ### Changes will be overwritten on the next build                      ###
// ##########################################################################
```

## Build Workflows

### Local Development Builds

**Trigger**: Building with PlatformIO on developer machine

**Script**: `.github/workflows/buildinfo.py`

**Configuration in platformio.ini**:
```ini
[env:target_mumo_v2x]
extra_scripts = pre:.github/workflows/buildinfo.py
```

**Process**:
1. Python script runs as PlatformIO pre-build script
2. Extracts version from latest git tag using `git describe`
3. Gets current commit hash using `git rev-parse --short HEAD`
4. Generates current UTC timestamp
5. Writes `buildinfo.cpp` with:
   - `buildEnvironment::local`
   - `buildType::development`
   - Version from latest tag (e.g., v2.1.3)
   - Current commit hash
   - Current timestamp

**Example Output**:
```cpp
const buildEnvironment buildInfo::theBuildEnvironment{buildEnvironment::local};
const buildType buildInfo::theBuildType{buildType::development};
const unsigned int buildInfo::mainVersionDigit   = 2;
const unsigned int buildInfo::minorVersionDigit  = 1;
const unsigned int buildInfo::patchVersionDigit  = 3;
const char* buildInfo::lastCommitTag    = "e8e8c6f";
const char* buildInfo::buildTimeStamp   = "Mon Oct 13 14:23:45 2025";
const time_t buildInfo::buildEpoch      = 1760430225;
```

### CI/Production Builds

**Trigger**: Push to `main`, `develop`, or `sonar_ci` branches

**Script**: `.github/workflows/testbuildrelease.yml`

**Process**:
1. GitHub Actions workflow extracts version information
2. Determines new version based on branch and commit message
3. Uses GitHub Actions `write-file-action` to generate `buildinfo.cpp`
4. Writes file with:
   - `buildEnvironment::ci`
   - `buildType::production`
   - New semantic version
   - Commit hash from GitHub context
   - Timestamp from GitHub Actions runner

## Semantic Versioning Strategy

The project follows **Semantic Versioning 2.0.0** (semver.org):
- **Major** (X.0.0): Breaking changes, incompatible API changes
- **Minor** (0.X.0): New features, backwards compatible
- **Patch** (0.0.X): Bug fixes, backwards compatible

### Version Determination

**Local builds**:
- Always use the latest git tag version
- Indicates development between releases
- Example: Building after v2.1.3 tag shows "v2.1.3" locally

**CI builds on main branch**:
- Version increments based on commit message keywords:
  - Contains `"major"`: Increment major, reset minor and patch to 0
  - Contains `"minor"`: Increment minor, reset patch to 0
  - Default: Increment patch
- Creates git tag with new version
- Creates GitHub release with binary artifact

**CI builds on other branches** (develop, sonar_ci):
- Use latest version with commit hash suffix
- Example: `v2.1.3-e8e8c6f`
- No git tag created
- No GitHub release created
- Binary attached to workflow run only

### Version Increment Examples

| Last Tag | Branch | Commit Message | New Version |
|----------|--------|----------------|-------------|
| v2.1.3 | main | "feature" | v2.1.4 |
| v2.1.3 | main | "minor update" | v2.2.0 |
| v2.1.3 | main | "major refactor" | v3.0.0 |
| v2.1.3 | develop | "any message" | v2.1.3-e8e8c6f |

## Git Tag Format

Tags follow the format: `vMAJOR.MINOR.PATCH`

Examples:
- `v1.0.0` - Initial release
- `v1.2.5` - Version 1.2.5
- `v2.0.0` - Major version 2

Git tags are created automatically by CI when building from the `main` branch.

## buildinfo.py Script Details

### Dependencies
- Python 3.x
- Git command-line tools
- PlatformIO environment

### Git Commands Used
```python
# Get latest tag
tag_hash = git rev-list --tags --max-count=1
latest_release_tag = git describe --tags {tag_hash}

# Get current commit
current_commit_hash = git rev-parse --short HEAD

# Parse version from tag (e.g., "v2.1.3-5-ge8e8c6f")
# Extracts: major=2, minor=1, patch=3, commits_ahead=5
```

### Version Parsing
The script handles git describe output:
- `v2.1.3`: Exact tag match
- `v2.1.3-5-ge8e8c6f`: 5 commits after v2.1.3 tag
  - Still uses v2.1.3 as version for local builds
  - Indicates development state

### Timestamp Format
- Human-readable: `"%a %b %d %H:%M:%S %Y"` (e.g., "Mon Oct 13 14:23:45 2025")
- Unix epoch: Integer seconds since 1970-01-01 00:00:00 UTC
- Both in UTC timezone

## GitHub Actions Workflow Details

### Version Extraction (Step: Get version data)

```bash
# Extract branch name
branchname=$(echo "${{ github.ref }}" | cut -d'/' -f 3-)

# Get commit hash
commithash=$(git rev-parse --short HEAD)

# Get timestamp
buildtimestamp=$(date +"%a %b %d %H:%M:%S %Y")
buildEpoch=$(date "+%s")

# Get version from main branch's latest tag
fulltag=$(git describe --tag $(git rev-parse --verify refs/remotes/origin/main))
# Parse semantic version components
```

### Version Selection Logic (Step: Determine which version to build)

```bash
if [ "$branchname" == "main" ]; then
  # Production release - increment version
  if [[ "$commit_message" == *"major"* ]]; then
    nextmajordigit = lastmajordigit + 1
    nextminordigit = 0
    nextpatchdigit = 0
  elif [[ "$commit_message" == *"minor"* ]]; then
    nextmajordigit = lastmajordigit
    nextminordigit = lastminordigit + 1
    nextpatchdigit = 0
  else
    nextmajordigit = lastmajordigit
    nextminordigit = lastminordigit
    nextpatchdigit = lastpatchdigit + 1
  fi
  buildversion = "v$nextmajordigit.$nextminordigit.$nextpatchdigit"
else
  # Development build - keep version, add commit hash
  buildversion = "v$lastmajordigit.$lastminordigit.$lastpatchdigit-$commithash"
fi
```

### File Generation (Step: Save Build info)

Uses `DamianReeves/write-file-action@master` to write `lib/version/buildinfo.cpp` directly in the workflow.

### Release Creation (Steps: Release when on main branch)

Only executes when `branchname == 'main'`:
1. Creates git tag with new version
2. Creates GitHub release
3. Attaches compiled `.elf` binary to release

## Usage in Firmware

### CLI Prompt

The version information is displayed in the CLI prompt (maincontroller.cpp):

```cpp
void mainController::showPrompt() {
    cli::sendResponse("\n\nhttps://github.com/Strooom\n");
    cli::sendResponse("v%u.%u.%u - #%s\n",
        buildInfo::mainVersionDigit,
        buildInfo::minorVersionDigit,
        buildInfo::patchVersionDigit,
        buildInfo::lastCommitTag);
    cli::sendResponse("%s %s build - %s\n",
        toString(buildInfo::theBuildEnvironment),
        toString(buildInfo::theBuildType),
        buildInfo::buildTimeStamp);
}
```

**Example Output**:
```
https://github.com/Strooom
v2.1.3 - #e8e8c6f
local development build - Mon Oct 13 14:23:45 2025
Creative Commons 4.0 - BY-NC-SA
Type '?' for help
```

### Version Comparison

The version numbers can be compared programmatically:

```cpp
if (buildInfo::mainVersionDigit >= 2) {
    // Feature available in v2.x and later
}

// Compare build timestamp
if (buildInfo::buildEpoch > someOtherTimestamp) {
    // This build is newer
}
```

### Conditional Features

Build environment and type can control feature availability:

```cpp
if (buildInfo::theBuildEnvironment == buildEnvironment::local) {
    // Enable extra debugging features in local builds
}

if (buildInfo::theBuildType == buildType::production) {
    // Disable verbose logging in production
}
```

## File Lifecycle

### .gitignore Entry
`buildinfo.cpp` should be in `.gitignore` to prevent accidental commits of generated files.

### Clean Builds
When switching between local and CI builds, or after git operations that change tags:
```bash
# Remove old generated file
rm lib/version/buildinfo.cpp

# Rebuild
pio run -e target_mumo_v2x
```

### First Build
If `buildinfo.cpp` doesn't exist:
- **Local**: Python script creates it before compilation
- **CI**: GitHub Actions writes it in workflow step

## Troubleshooting

### Problem: Incorrect version in local build

**Cause**: Git tags not fetched
**Solution**:
```bash
git fetch --tags
pio run -e target_mumo_v2x
```

### Problem: Build fails with missing buildinfo.cpp

**Cause**: Pre-build script not executing
**Solution**:
- Verify `extra_scripts = pre:.github/workflows/buildinfo.py` in platformio.ini
- Check Python is in PATH
- Run manually: `python .github/workflows/buildinfo.py`

### Problem: Old timestamp after rebuild

**Cause**: Incremental build didn't regenerate file
**Solution**:
```bash
pio run -t clean
pio run -e target_mumo_v2x
```

### Problem: CI build has wrong version

**Cause**: Workflow extracted wrong version from git describe
**Solution**:
- Check git tags exist on main branch
- Verify `fetch-depth: 0` in workflow checkout step
- Review GitHub Actions logs for version extraction step

## Best Practices

1. **Never manually edit buildinfo.cpp** - It will be overwritten
2. **Use meaningful commit messages** - They control version increments on main
3. **Tag carefully** - Tags on main branch become official releases
4. **Test before merging to main** - Develop on feature branches or develop branch
5. **Check version in CLI** - Always verify correct version after building
6. **Clean build after tag changes** - Ensures correct version is embedded

## Related Files

- `lib/version/buildinfo.hpp` - Static interface definition
- `lib/version/buildenvironment.hpp/cpp` - Build environment enumeration
- `lib/version/buildtype.hpp/cpp` - Build type enumeration
- `.github/workflows/buildinfo.py` - Local build script
- `.github/workflows/testbuildrelease.yml` - CI workflow
- `platformio.ini` - Configures pre-build script

## Future Enhancements

Potential improvements:
- Support for pre-release versions (e.g., v2.1.0-beta.1)
- Build number counter separate from git commits
- Dirty working directory detection (local changes)
- Git branch name embedded in development builds
- Automated changelog generation from commit messages
